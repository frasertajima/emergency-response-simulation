! BoundaryPINN - Pure Physics Dispersion Solver with Boundary Handling
!
! CUDA Fortran extension of SimplePINN (v41) with:
! - Configurable boundary conditions (wall, absorbing, reflecting, periodic)
! - Obstacle mask support for buildings/terrain
! - Boundary-aware upwind advection and diffusion
!
! Physics: dC/dt = -u·∇C + D∇²C - kC
!
! v42 - Boundary Extension
! Date: 2026-01-23
!
! Boundary types (inspired by tensor12 fluid_solver 'b' parameter):
!   0 = PERIODIC   : Wrap-around (original SimplePINN)
!   1 = WALL       : No-flux Neumann (dC/dn = 0)
!   2 = ABSORBING  : Open boundary (C = 0)
!   3 = REFLECTING : Velocity component flipped

module boundary_pinn_module
    use cudafor
    implicit none

    ! Boundary type constants
    integer, parameter :: BC_PERIODIC = 0
    integer, parameter :: BC_WALL = 1
    integer, parameter :: BC_ABSORBING = 2
    integer, parameter :: BC_REFLECTING = 3

    ! Physics parameters (constant memory for fast kernel access)
    real(4), constant :: dx_device, D_device, k_device

    ! Boundary conditions (constant memory)
    ! Order: x-, x+, y-, y+, z-, z+
    integer, constant :: bc_device(6)

contains

    ! =========================================================================
    ! CUDA Kernel: Apply boundary conditions to concentration field
    ! =========================================================================

    attributes(global) subroutine apply_boundary_kernel( &
        C, nx, ny, nz)

        implicit none
        integer, value :: nx, ny, nz
        real(4), device :: C(nx, ny, nz)

        integer :: i, j, k, idx
        integer :: bc_xm, bc_xp, bc_ym, bc_yp, bc_zm, bc_zp

        ! Get boundary conditions from constant memory
        bc_xm = bc_device(1)
        bc_xp = bc_device(2)
        bc_ym = bc_device(3)
        bc_yp = bc_device(4)
        bc_zm = bc_device(5)
        bc_zp = bc_device(6)

        ! Thread index (1D for boundary processing)
        idx = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        ! X- boundary (face i=1)
        if (idx <= ny * nz) then
            j = mod(idx - 1, ny) + 1
            k = (idx - 1) / ny + 1
            if (j <= ny .and. k <= nz) then
                if (bc_xm == BC_WALL .or. bc_xm == BC_REFLECTING) then
                    C(1, j, k) = C(2, j, k)
                else if (bc_xm == BC_ABSORBING) then
                    C(1, j, k) = 0.0
                endif
            endif
        endif

        ! X+ boundary (face i=nx)
        if (idx <= ny * nz) then
            j = mod(idx - 1, ny) + 1
            k = (idx - 1) / ny + 1
            if (j <= ny .and. k <= nz) then
                if (bc_xp == BC_WALL .or. bc_xp == BC_REFLECTING) then
                    C(nx, j, k) = C(nx-1, j, k)
                else if (bc_xp == BC_ABSORBING) then
                    C(nx, j, k) = 0.0
                endif
            endif
        endif

        ! Y- boundary (face j=1)
        if (idx <= nx * nz) then
            i = mod(idx - 1, nx) + 1
            k = (idx - 1) / nx + 1
            if (i <= nx .and. k <= nz) then
                if (bc_ym == BC_WALL .or. bc_ym == BC_REFLECTING) then
                    C(i, 1, k) = C(i, 2, k)
                else if (bc_ym == BC_ABSORBING) then
                    C(i, 1, k) = 0.0
                endif
            endif
        endif

        ! Y+ boundary (face j=ny)
        if (idx <= nx * nz) then
            i = mod(idx - 1, nx) + 1
            k = (idx - 1) / nx + 1
            if (i <= nx .and. k <= nz) then
                if (bc_yp == BC_WALL .or. bc_yp == BC_REFLECTING) then
                    C(i, ny, k) = C(i, ny-1, k)
                else if (bc_yp == BC_ABSORBING) then
                    C(i, ny, k) = 0.0
                endif
            endif
        endif

        ! Z- boundary (face k=1)
        if (idx <= nx * ny) then
            i = mod(idx - 1, nx) + 1
            j = (idx - 1) / nx + 1
            if (i <= nx .and. j <= ny) then
                if (bc_zm == BC_WALL .or. bc_zm == BC_REFLECTING) then
                    C(i, j, 1) = C(i, j, 2)
                else if (bc_zm == BC_ABSORBING) then
                    C(i, j, 1) = 0.0
                endif
            endif
        endif

        ! Z+ boundary (face k=nz)
        if (idx <= nx * ny) then
            i = mod(idx - 1, nx) + 1
            j = (idx - 1) / nx + 1
            if (i <= nx .and. j <= ny) then
                if (bc_zp == BC_WALL .or. bc_zp == BC_REFLECTING) then
                    C(i, j, nz) = C(i, j, nz-1)
                else if (bc_zp == BC_ABSORBING) then
                    C(i, j, nz) = 0.0
                endif
            endif
        endif

    end subroutine apply_boundary_kernel


    ! =========================================================================
    ! CUDA Kernel: Apply velocity boundary conditions
    ! =========================================================================

    attributes(global) subroutine apply_velocity_boundary_kernel( &
        u, v, w, nx, ny, nz)

        implicit none
        integer, value :: nx, ny, nz
        real(4), device :: u(nx, ny, nz), v(nx, ny, nz), w(nx, ny, nz)

        integer :: i, j, k, idx
        integer :: bc_xm, bc_xp, bc_ym, bc_yp, bc_zm, bc_zp

        bc_xm = bc_device(1)
        bc_xp = bc_device(2)
        bc_ym = bc_device(3)
        bc_yp = bc_device(4)
        bc_zm = bc_device(5)
        bc_zp = bc_device(6)

        idx = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        ! X boundaries - affect u component
        if (idx <= ny * nz) then
            j = mod(idx - 1, ny) + 1
            k = (idx - 1) / ny + 1
            if (j <= ny .and. k <= nz) then
                ! X- boundary
                if (bc_xm == BC_WALL) then
                    u(1, j, k) = 0.0
                else if (bc_xm == BC_REFLECTING) then
                    u(1, j, k) = -u(2, j, k)
                endif
                ! X+ boundary
                if (bc_xp == BC_WALL) then
                    u(nx, j, k) = 0.0
                else if (bc_xp == BC_REFLECTING) then
                    u(nx, j, k) = -u(nx-1, j, k)
                endif
            endif
        endif

        ! Y boundaries - affect v component
        if (idx <= nx * nz) then
            i = mod(idx - 1, nx) + 1
            k = (idx - 1) / nx + 1
            if (i <= nx .and. k <= nz) then
                ! Y- boundary
                if (bc_ym == BC_WALL) then
                    v(i, 1, k) = 0.0
                else if (bc_ym == BC_REFLECTING) then
                    v(i, 1, k) = -v(i, 2, k)
                endif
                ! Y+ boundary
                if (bc_yp == BC_WALL) then
                    v(i, ny, k) = 0.0
                else if (bc_yp == BC_REFLECTING) then
                    v(i, ny, k) = -v(i, ny-1, k)
                endif
            endif
        endif

        ! Z boundaries - affect w component
        if (idx <= nx * ny) then
            i = mod(idx - 1, nx) + 1
            j = (idx - 1) / nx + 1
            if (i <= nx .and. j <= ny) then
                ! Z- boundary
                if (bc_zm == BC_WALL) then
                    w(i, j, 1) = 0.0
                else if (bc_zm == BC_REFLECTING) then
                    w(i, j, 1) = -w(i, j, 2)
                endif
                ! Z+ boundary
                if (bc_zp == BC_WALL) then
                    w(i, j, nz) = 0.0
                else if (bc_zp == BC_REFLECTING) then
                    w(i, j, nz) = -w(i, j, nz-1)
                endif
            endif
        endif

    end subroutine apply_velocity_boundary_kernel


    ! =========================================================================
    ! CUDA Kernel: Apply obstacle mask
    ! =========================================================================

    attributes(global) subroutine apply_obstacle_kernel( &
        C, u, v, w, obstacle_mask, nx, ny, nz)

        implicit none
        integer, value :: nx, ny, nz
        real(4), device :: C(nx, ny, nz)
        real(4), device :: u(nx, ny, nz), v(nx, ny, nz), w(nx, ny, nz)
        integer(1), device :: obstacle_mask(nx, ny, nz)  ! 1 = obstacle, 0 = fluid

        integer :: i, j, k

        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
        k = (blockIdx%z - 1) * blockDim%z + threadIdx%z

        if (i > nx .or. j > ny .or. k > nz) return

        ! Zero out fields inside obstacles
        if (obstacle_mask(i, j, k) == 1) then
            C(i, j, k) = 0.0
            u(i, j, k) = 0.0
            v(i, j, k) = 0.0
            w(i, j, k) = 0.0
        endif

    end subroutine apply_obstacle_kernel


    ! =========================================================================
    ! CUDA Kernel: Compute dC/dt with boundary-aware indexing
    ! =========================================================================

    attributes(global) subroutine compute_dCdt_bounded_kernel( &
        u, v, w, C, dCdt, obstacle_mask, nx, ny, nz)

        implicit none
        integer, value :: nx, ny, nz
        real(4), device :: u(nx, ny, nz), v(nx, ny, nz), w(nx, ny, nz)
        real(4), device :: C(nx, ny, nz), dCdt(nx, ny, nz)
        integer(1), device :: obstacle_mask(nx, ny, nz)

        integer :: i, j, k
        integer :: i_prev, i_next, j_prev, j_next, k_prev, k_next
        real(4) :: u_val, v_val, w_val, C_val
        real(4) :: C_xm, C_xp, C_ym, C_yp, C_zm, C_zp
        real(4) :: dCdx, dCdy, dCdz
        real(4) :: d2Cdx2, d2Cdy2, d2Cdz2, laplacian
        real(4) :: advection, diffusion, reaction
        integer :: bc_xm, bc_xp, bc_ym, bc_yp, bc_zm, bc_zp

        ! Thread indices
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
        k = (blockIdx%z - 1) * blockDim%z + threadIdx%z

        if (i > nx .or. j > ny .or. k > nz) return

        ! Skip obstacles
        if (obstacle_mask(i, j, k) == 1) then
            dCdt(i, j, k) = 0.0
            return
        endif

        ! Get boundary conditions
        bc_xm = bc_device(1)
        bc_xp = bc_device(2)
        bc_ym = bc_device(3)
        bc_yp = bc_device(4)
        bc_zm = bc_device(5)
        bc_zp = bc_device(6)

        ! Get values at current point
        u_val = u(i, j, k)
        v_val = v(i, j, k)
        w_val = w(i, j, k)
        C_val = C(i, j, k)

        ! =====================================================================
        ! Neighbor indices with boundary handling
        ! =====================================================================

        ! X-direction neighbors
        i_prev = i - 1
        i_next = i + 1

        if (i == 1) then
            if (bc_xm == BC_PERIODIC) then
                i_prev = nx
            else
                i_prev = 1  ! Use boundary value
            endif
        endif

        if (i == nx) then
            if (bc_xp == BC_PERIODIC) then
                i_next = 1
            else
                i_next = nx  ! Use boundary value
            endif
        endif

        ! Y-direction neighbors
        j_prev = j - 1
        j_next = j + 1

        if (j == 1) then
            if (bc_ym == BC_PERIODIC) then
                j_prev = ny
            else
                j_prev = 1
            endif
        endif

        if (j == ny) then
            if (bc_yp == BC_PERIODIC) then
                j_next = 1
            else
                j_next = ny
            endif
        endif

        ! Z-direction neighbors
        k_prev = k - 1
        k_next = k + 1

        if (k == 1) then
            if (bc_zm == BC_PERIODIC) then
                k_prev = nz
            else
                k_prev = 1
            endif
        endif

        if (k == nz) then
            if (bc_zp == BC_PERIODIC) then
                k_next = 1
            else
                k_next = nz
            endif
        endif

        ! Get neighbor concentration values
        C_xm = C(i_prev, j, k)
        C_xp = C(i_next, j, k)
        C_ym = C(i, j_prev, k)
        C_yp = C(i, j_next, k)
        C_zm = C(i, j, k_prev)
        C_zp = C(i, j, k_next)

        ! Handle absorbing boundaries (force neighbor to 0)
        if (i == 1 .and. bc_xm == BC_ABSORBING) C_xm = 0.0
        if (i == nx .and. bc_xp == BC_ABSORBING) C_xp = 0.0
        if (j == 1 .and. bc_ym == BC_ABSORBING) C_ym = 0.0
        if (j == ny .and. bc_yp == BC_ABSORBING) C_yp = 0.0
        if (k == 1 .and. bc_zm == BC_ABSORBING) C_zm = 0.0
        if (k == nz .and. bc_zp == BC_ABSORBING) C_zp = 0.0

        ! =====================================================================
        ! 1. ADVECTION (Upwind Scheme)
        ! =====================================================================

        ! X-direction upwind
        if (u_val > 0.0) then
            dCdx = (C_val - C_xm) / dx_device
        else
            dCdx = (C_xp - C_val) / dx_device
        endif

        ! Y-direction upwind
        if (v_val > 0.0) then
            dCdy = (C_val - C_ym) / dx_device
        else
            dCdy = (C_yp - C_val) / dx_device
        endif

        ! Z-direction upwind
        if (w_val > 0.0) then
            dCdz = (C_val - C_zm) / dx_device
        else
            dCdz = (C_zp - C_val) / dx_device
        endif

        advection = -(u_val * dCdx + v_val * dCdy + w_val * dCdz)

        ! =====================================================================
        ! 2. DIFFUSION (Central Differences)
        ! =====================================================================

        d2Cdx2 = (C_xp - 2.0*C_val + C_xm) / (dx_device**2)
        d2Cdy2 = (C_yp - 2.0*C_val + C_ym) / (dx_device**2)
        d2Cdz2 = (C_zp - 2.0*C_val + C_zm) / (dx_device**2)

        laplacian = d2Cdx2 + d2Cdy2 + d2Cdz2
        diffusion = D_device * laplacian

        ! =====================================================================
        ! 3. REACTION (Point-wise Decay)
        ! =====================================================================

        reaction = -k_device * C_val

        ! =====================================================================
        ! Total rate of change
        ! =====================================================================

        dCdt(i, j, k) = advection + diffusion + reaction

    end subroutine compute_dCdt_bounded_kernel


    ! =========================================================================
    ! CUDA Kernel: Euler time integration
    ! =========================================================================

    attributes(global) subroutine euler_update_kernel(C, dCdt, dt, nx, ny, nz)
        implicit none
        integer, value :: nx, ny, nz
        real(4), value :: dt
        real(4), device :: C(nx, ny, nz), dCdt(nx, ny, nz)
        integer :: i, j, k

        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
        k = (blockIdx%z - 1) * blockDim%z + threadIdx%z

        if (i <= nx .and. j <= ny .and. k <= nz) then
            C(i, j, k) = max(0.0, C(i, j, k) + dCdt(i, j, k) * dt)
        endif
    end subroutine euler_update_kernel


    ! =========================================================================
    ! Host Subroutine: Set boundary conditions
    ! =========================================================================

    subroutine set_boundary_conditions(bc_xm, bc_xp, bc_ym, bc_yp, bc_zm, bc_zp)
        implicit none
        integer, intent(in) :: bc_xm, bc_xp, bc_ym, bc_yp, bc_zm, bc_zp
        integer :: bc_host(6)

        bc_host(1) = bc_xm
        bc_host(2) = bc_xp
        bc_host(3) = bc_ym
        bc_host(4) = bc_yp
        bc_host(5) = bc_zm
        bc_host(6) = bc_zp

        bc_device = bc_host
    end subroutine set_boundary_conditions


    ! =========================================================================
    ! Host Subroutine: Single timestep with boundaries
    ! =========================================================================

    subroutine timestep_bounded(u, v, w, C, obstacle_mask, nx, ny, nz, dx, D, k, dt)
        implicit none

        integer, intent(in) :: nx, ny, nz
        real(4), intent(in) :: dx, D, k, dt
        real(4), device, intent(inout) :: u(nx, ny, nz), v(nx, ny, nz), w(nx, ny, nz)
        real(4), device, intent(inout) :: C(nx, ny, nz)
        integer(1), device, intent(in) :: obstacle_mask(nx, ny, nz)

        real(4), device, allocatable :: dCdt(:,:,:)
        type(dim3) :: blocks3d, threads3d
        integer :: blocks1d, threads1d, max_face, istat

        allocate(dCdt(nx, ny, nz))

        ! Set physics parameters
        dx_device = dx
        D_device = D
        k_device = k

        ! 3D kernel configuration
        threads3d = dim3(8, 8, 8)
        blocks3d = dim3(ceiling(real(nx)/8.0), &
                       ceiling(real(ny)/8.0), &
                       ceiling(real(nz)/8.0))

        ! 1D kernel configuration for boundaries
        threads1d = 256
        max_face = max(nx*ny, max(ny*nz, nx*nz))
        blocks1d = ceiling(real(max_face) / threads1d)

        ! 1. Apply boundary conditions to velocity
        call apply_velocity_boundary_kernel<<<blocks1d, threads1d>>>( &
            u, v, w, nx, ny, nz)

        ! 2. Apply obstacle mask
        call apply_obstacle_kernel<<<blocks3d, threads3d>>>( &
            C, u, v, w, obstacle_mask, nx, ny, nz)

        ! 3. Compute dC/dt
        call compute_dCdt_bounded_kernel<<<blocks3d, threads3d>>>( &
            u, v, w, C, dCdt, obstacle_mask, nx, ny, nz)

        ! 4. Euler update
        call euler_update_kernel<<<blocks3d, threads3d>>>(C, dCdt, dt, nx, ny, nz)

        ! 5. Apply boundary conditions to concentration
        call apply_boundary_kernel<<<blocks1d, threads1d>>>(C, nx, ny, nz)

        ! 6. Re-apply obstacle mask (ensure C stays zero inside obstacles after diffusion)
        call apply_obstacle_kernel<<<blocks3d, threads3d>>>( &
            C, u, v, w, obstacle_mask, nx, ny, nz)

        ! Synchronize
        istat = cudaDeviceSynchronize()
        if (istat /= 0) then
            print *, "CUDA kernel error:", istat
            stop
        endif

        deallocate(dCdt)

    end subroutine timestep_bounded

end module boundary_pinn_module
